---
alwaysApply: true
---
# Rapha Development Rules

## Core Development Principles

### Code Quality Standards
- **Production Ready**: Every line of code must be production-ready from day one
- **Simplest Solution**: Always choose the simplest, most straightforward approach
- **Clean Code**: Write clean, readable, and maintainable code
- **Documentation**: Document all functions, components, and complex logic inline
- **Modular Design**: Create reusable, modular components and utilities
- **Scalability First**: Design with future growth and feature additions in mind

### Communication Protocol
- **Ask Before Assuming**: If uncertain about a request, implementation approach, or technical decision, ASK for clarification
- **No Jumping Ahead**: Only build what is explicitly requested - do not anticipate or build ahead
- **Express Limitations**: If unable to complete a task or unsure how to proceed, communicate this immediately
- **Seek Clarification**: When confused about requirements, ask specific questions rather than guessing

## Technology Stack Requirements

### Framework & Tools
- **React Native** with Expo Go framework
- **TypeScript** for all code (no JavaScript files)
- **Supabase** for backend services and database
- **EAS** for building and deployment
- **Expo Router** for navigation (file-based routing)

### Development Dependencies
- **ESLint + Prettier** for code formatting and linting
- **Expo Dev Tools** for debugging and development
- **React Native Reanimated 3** for animations (required for 0.2s universal timing)

## Project Structure & Organization

### Directory Structure
```
/src
  /components
    /ui          # Reusable UI components
    /forms       # Form-specific components
    /navigation  # Navigation-related components
  /screens       # Screen components organized by feature
  /services      # API calls, Supabase integration
  /utils         # Helper functions and utilities
  /hooks         # Custom React hooks
  /types         # TypeScript type definitions
  /constants     # App constants and configuration
  /animations    # Animation configurations and presets
/assets          # Images, fonts, icons
```

### File Naming Conventions
- **Components**: PascalCase (e.g., `DailyDevotional.tsx`)
- **Hooks**: camelCase with "use" prefix (e.g., `useDevotionalData.ts`)
- **Utils**: camelCase (e.g., `dateHelpers.ts`)
- **Types**: PascalCase with "Types" suffix (e.g., `DevotionalTypes.ts`)
- **Constants**: SCREAMING_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)

## UI/UX Implementation Standards

### Animation Requirements
- **Universal Duration**: 0.2s for ALL micro-interactions (no exceptions)
- **Easing**: Use `Easing.out(Easing.cubic)` for natural feel
- **Performance**: Maintain 60fps - use `useNativeDriver: true` when possible
- **Interactive Feedback**: Every touchable element must have visual feedback
- **Loading States**: Animate all loading and state transitions

### Design System Implementation
- **Consistent Spacing**: Use a spacing scale (4, 8, 16, 24, 32px multiples)
- **Typography Scale**: Define and use consistent font sizes and weights
- **Color System**: Centralized color palette with semantic naming
- **Component Library**: Build reusable UI components before custom implementations

### Spatial Consistency Rules
- **Fixed Positioning**: Maintain component positions across screens for mental mapping
- **Navigation Persistence**: Bottom tab bar and header positioning must remain consistent
- **Transition Continuity**: Elements should animate to new positions, never disappear/reappear abruptly

## Code Architecture Standards

### Component Structure
```typescript
// Required component structure
interface ComponentProps {
  // Props definition
}

const ComponentName: React.FC<ComponentProps> = ({ ...props }) => {
  // Hooks at top
  // State management
  // Effect hooks
  // Event handlers
  // Render logic
  
  return (
    // JSX with proper accessibility
  );
};

export default ComponentName;
```

### State Management
- **Local State**: Use `useState` for component-specific state
- **Global State**: Use React Context for app-wide state (user data, settings)
- **Server State**: Use React Query/TanStack Query for API data management
- **Supabase Integration**: Centralize all database operations in service files

### Error Handling
- **Try-Catch Blocks**: Wrap all async operations
- **User-Friendly Messages**: Never expose technical errors to users
- **Error Boundaries**: Implement for component-level error catching
- **Logging**: Use consistent logging for debugging (console.log in development only)

## Performance & Scalability Standards

### Optimization Requirements
- **Lazy Loading**: Implement for screens and heavy components
- **Image Optimization**: Use appropriate formats and sizes
- **Bundle Splitting**: Keep bundle sizes minimal
- **Memory Management**: Properly cleanup subscriptions and listeners

### Supabase Integration Standards
- **Connection Pooling**: Efficiently manage database connections
- **Query Optimization**: Use proper indexing and query structures
- **Real-time Subscriptions**: Implement for community features only when needed
- **Caching Strategy**: Cache frequently accessed data locally

### Scalability Patterns
- **Service Layer**: Abstract all external API calls
- **Utility Functions**: Create reusable utility functions
- **Hook Abstractions**: Custom hooks for complex logic
- **Component Composition**: Favor composition over inheritance

## Security & Best Practices

### Data Handling
- **Type Safety**: Use TypeScript strictly - no `any` types
- **Input Validation**: Validate all user inputs
- **Secure Storage**: Use Expo SecureStore for sensitive data
- **API Security**: Implement proper authentication and authorization

### Code Quality Checks
- **Linting**: Code must pass ESLint without warnings
- **Type Checking**: No TypeScript errors allowed
- **Testing**: Write unit tests for utility functions and critical logic
- **Documentation**: JSDoc comments for all public functions and components

## Development Workflow

### Before Starting Any Task
1. Understand the exact requirements
2. Ask clarifying questions if anything is unclear
3. Plan the approach and architecture
4. Identify any dependencies or blockers

### During Development
1. Write clean, documented code
2. Test functionality thoroughly
3. Ensure animations meet 0.2s standard
4. Verify responsive design on different screen sizes
5. Check performance and memory usage

### Before Completion
1. Code review checklist completion
2. Documentation updated
3. No console.logs or debugging code
4. Proper error handling implemented
5. TypeScript strict mode compliance

## Specific Technical Requirements

### Animation Implementation
```typescript
// Required animation setup
import Animated, { 
  useAnimatedStyle, 
  withTiming, 
  Easing 
} from 'react-native-reanimated';

const ANIMATION_CONFIG = {
  duration: 200, // 0.2s universal standard
  easing: Easing.out(Easing.cubic),
};
```

### Component Documentation Template
```typescript
/**
 * ComponentName - Brief description of component purpose
 * 
 * @param prop1 - Description of prop1
 * @param prop2 - Description of prop2
 * @returns JSX element
 * 
 * @example
 * <ComponentName prop1="value" prop2={data} />
 */
```

### API Service Pattern
```typescript
// services/apiService.ts
export class ApiService {
  /**
   * Method description
   * @param params - Parameter description
   * @returns Promise with typed response
   */
  static async methodName(params: ParamType): Promise<ReturnType> {
    try {
      // Implementation
    } catch (error) {
      // Proper error handling
      throw new Error('User-friendly error message');
    }
  }
}
```

## Final Reminders

- **Quality Over Speed**: Take time to write proper, scalable code
- **Ask Questions**: Better to clarify than assume
- **Document Everything**: Future developers (including yourself) will thank you
- **Test Thoroughly**: Every feature should work flawlessly before completion
- **Stay Organized**: Clean project structure is non-negotiable
- **Production Ready**: Every commit should be deployable